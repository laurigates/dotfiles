#!/usr/bin/env bash

# Google Chat Format Converter
# Converts Markdown text to Google Chat compatible formatting

set -euo pipefail

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly NC='\033[0m' # No Color

# Help text
show_help() {
    cat << EOF
Google Chat Format Converter

Convert Markdown text to Google Chat compatible formatting.

USAGE:
    google-chat-format [OPTIONS] [FILE|TEXT]

OPTIONS:
    -h, --help      Show this help message
    -c, --clipboard Process clipboard content (macOS/Linux)
    -f, --file FILE Process specific file
    -i, --in-place  Edit file in-place (with -f)
    -p, --preview   Show preview without applying changes

EXAMPLES:
    # Convert text from argument
    google-chat-format "# Header\n**bold text**"

    # Convert from file
    google-chat-format -f document.md

    # Convert clipboard content
    google-chat-format -c

    # Preview changes
    google-chat-format -p -f document.md

    # Edit file in-place
    google-chat-format -f document.md -i

If no arguments provided, reads from stdin.
EOF
}

# Convert text to Google Chat format
convert_text() {
    local text="$1"

    # Convert headers to bold
    text=$(echo "$text" | sed -E 's/^### (.*)/\*\1\*/g')
    text=$(echo "$text" | sed -E 's/^## (.*)/\*\1\*/g')
    text=$(echo "$text" | sed -E 's/^# (.*)/\*\1\*/g')

    # Convert double asterisk bold to single asterisk
    text=$(echo "$text" | sed -E 's/\*\*([^*]+)\*\*/\*\1\*/g')

    # Convert underscore bold to asterisk
    text=$(echo "$text" | sed -E 's/__([^_]+)__/\*\1\*/g')

    # Convert list markers to bullet points
    text=$(echo "$text" | sed -E 's/^[[:space:]]*[-*+][[:space:]]/â€¢ /g')

    # Fix label formatting (convert **Label:** to *Label:*)
    text=$(echo "$text" | sed -E 's/\*\*([^:]+):\*\*/\*\1:\*/g')

    # Remove excessive blank lines (more than 2 consecutive)
    text=$(echo "$text" | sed -E '/^[[:space:]]*$/N;/\n[[:space:]]*$/N;/\n[[:space:]]*\n[[:space:]]*$/d')

    # Ensure single blank line between sections (after bold headers)
    text=$(echo "$text" | sed -E '/^\*.*\*$/{N;/\n[^[:space:]]/s/\n/\n\n/;}')

    echo "$text"
}

# Get clipboard content (cross-platform)
get_clipboard() {
    if command -v pbpaste >/dev/null 2>&1; then
        # macOS
        pbpaste
    elif command -v xclip >/dev/null 2>&1; then
        # Linux with xclip
        xclip -selection clipboard -o
    elif command -v xsel >/dev/null 2>&1; then
        # Linux with xsel
        xsel --clipboard --output
    else
        echo "Error: No clipboard tool found (pbpaste, xclip, or xsel)" >&2
        exit 1
    fi
}

# Set clipboard content (cross-platform)
set_clipboard() {
    local content="$1"
    if command -v pbcopy >/dev/null 2>&1; then
        # macOS
        echo "$content" | pbcopy
    elif command -v xclip >/dev/null 2>&1; then
        # Linux with xclip
        echo "$content" | xclip -selection clipboard
    elif command -v xsel >/dev/null 2>&1; then
        # Linux with xsel
        echo "$content" | xsel --clipboard --input
    else
        echo "Error: No clipboard tool found (pbcopy, xclip, or xsel)" >&2
        exit 1
    fi
}

# Main function
main() {
    local file=""
    local use_clipboard=false
    local in_place=false
    local preview=false
    local input_text=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -c|--clipboard)
                use_clipboard=true
                shift
                ;;
            -f|--file)
                file="$2"
                shift 2
                ;;
            -i|--in-place)
                in_place=true
                shift
                ;;
            -p|--preview)
                preview=true
                shift
                ;;
            *)
                # Treat as input text
                input_text="$1"
                shift
                ;;
        esac
    done

    # Get input text
    if [[ "$use_clipboard" == true ]]; then
        input_text=$(get_clipboard)
        echo -e "${YELLOW}Processing clipboard content...${NC}" >&2
    elif [[ -n "$file" ]]; then
        if [[ ! -f "$file" ]]; then
            echo -e "${RED}Error: File '$file' not found${NC}" >&2
            exit 1
        fi
        input_text=$(cat "$file")
        echo -e "${YELLOW}Processing file: $file${NC}" >&2
    elif [[ -z "$input_text" ]]; then
        # Read from stdin
        input_text=$(cat)
        echo -e "${YELLOW}Processing stdin...${NC}" >&2
    fi

    # Convert the text
    converted_text=$(convert_text "$input_text")

    # Handle output
    if [[ "$preview" == true ]]; then
        echo -e "${GREEN}=== ORIGINAL ===${NC}"
        echo "$input_text"
        echo -e "${GREEN}=== CONVERTED ===${NC}"
        echo "$converted_text"
    elif [[ "$in_place" == true && -n "$file" ]]; then
        echo "$converted_text" > "$file"
        echo -e "${GREEN}File updated: $file${NC}" >&2
    elif [[ "$use_clipboard" == true ]]; then
        set_clipboard "$converted_text"
        echo -e "${GREEN}Converted text copied to clipboard${NC}" >&2
    else
        echo "$converted_text"
    fi
}

# Run main function with all arguments
main "$@"
