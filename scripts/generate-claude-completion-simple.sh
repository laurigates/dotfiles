#!/usr/bin/env bash
# Simple, robust Claude CLI completion generator
# This script creates zsh completion by using a more straightforward parsing approach

set -euo pipefail

# Colors and formatting
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly DOTFILES_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"
readonly COMPLETION_FILE="${DOTFILES_DIR}/dot_zfunc/_claude"

log() { echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $*" >&2; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; exit 1; }
success() { echo -e "${GREEN}[SUCCESS]${NC} $*" >&2; }

check_claude_cli() {
    if ! command -v claude >/dev/null 2>&1; then
        error "Claude CLI not found in PATH"
    fi
    log "Found claude CLI: $(claude --version 2>/dev/null | head -1 || echo 'unknown version')"
}

# Generate the complete zsh completion file using the current working version as a template
# but with updated help text parsing
generate_completion() {
    log "Generating updated Claude CLI completion..."
    
    # Create directory if needed
    mkdir -p "$(dirname "$COMPLETION_FILE")"
    
    # Get current help outputs
    local main_help=$(claude --help 2>/dev/null)
    local config_help=$(claude config --help 2>/dev/null)
    local mcp_help=$(claude mcp --help 2>/dev/null)
    
    # Extract commands from main help
    local main_commands=$(echo "$main_help" | sed -n '/^Commands:/,/^$/p' | grep -E '^  [a-z]' | sed 's/^  //' | while read -r line; do
        cmd=$(echo "$line" | awk '{print $1}')
        desc=$(echo "$line" | cut -d' ' -f2- | sed 's/^ *//')
        # Clean up descriptions to remove extra formatting
        desc=$(echo "$desc" | sed 's/\[[^]]*\]//g' | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//')
        echo "        '$cmd:$desc'"
    done)
    
    # Extract config commands
    local config_commands=$(echo "$config_help" | sed -n '/^Commands:/,/^$/p' | grep -E '^  [a-z]' | sed 's/^  //' | while read -r line; do
        cmd=$(echo "$line" | awk '{print $1}')
        desc=$(echo "$line" | cut -d' ' -f2- | sed 's/^ *//')
        # Clean up descriptions
        desc=$(echo "$desc" | sed 's/\[[^]]*\]//g' | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//')
        echo "        '$cmd:$desc'"
    done)
    
    # Extract MCP commands
    local mcp_commands=$(echo "$mcp_help" | sed -n '/^Commands:/,/^$/p' | grep -E '^  [a-z]' | sed 's/^  //' | while read -r line; do
        cmd=$(echo "$line" | awk '{print $1}')
        desc=$(echo "$line" | cut -d' ' -f2- | sed 's/^ *//')
        # Clean up descriptions
        desc=$(echo "$desc" | sed 's/\[[^]]*\]//g' | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//')
        echo "        '$cmd:$desc'"
    done)

cat > "$COMPLETION_FILE" << 'COMPLETION_EOF'
#compdef claude

# Zsh completion for Claude Code CLI
# Auto-generated by scripts/generate-claude-completion-simple.sh
# Maintained as part of chezmoi dotfiles configuration

_claude() {
    local -a commands
    local context state state_descr line
    typeset -A opt_args

    commands=(
COMPLETION_EOF

    # Add the dynamically extracted commands
    echo "$main_commands" >> "$COMPLETION_FILE"

cat >> "$COMPLETION_FILE" << 'COMPLETION_EOF'
    )

    _arguments -C \
        '(-d --debug)'{-d,--debug}'[Enable debug mode]' \
        '--verbose[Override verbose mode setting from config]' \
        '(-p --print)'{-p,--print}'[Print response and exit (useful for pipes)]' \
        '--output-format[Output format for --print]:format:(text json stream-json)' \
        '--input-format[Input format for --print]:format:(text stream-json)' \
        '--mcp-debug[DEPRECATED. Use --debug instead. Enable MCP debug mode]' \
        '--dangerously-skip-permissions[Bypass all permission checks]' \
        '--allowedTools[Comma or space-separated list of tool names to allow]:tools:' \
        '--disallowedTools[Comma or space-separated list of tool names to deny]:tools:' \
        '--mcp-config[Load MCP servers from JSON files or strings]:configs:_files' \
        '--append-system-prompt[Append a system prompt to the default system prompt]:prompt:' \
        '--permission-mode[Permission mode to use for the session]:mode:(acceptEdits bypassPermissions default plan)' \
        '(-c --continue)'{-c,--continue}'[Continue the most recent conversation]' \
        '(-r --resume)'{-r,--resume}'[Resume a conversation]:sessionId:' \
        '--model[Model for the current session]:model:_claude_models' \
        '--fallback-model[Enable automatic fallback to specified model]:model:_claude_models' \
        '--settings[Path to a settings JSON file or a JSON string]:file:_files' \
        '--add-dir[Additional directories to allow tool access to]:directories:_files -/' \
        '--ide[Automatically connect to IDE on startup if exactly one valid IDE is available]' \
        '--strict-mcp-config[Only use MCP servers from --mcp-config]' \
        '--session-id[Use a specific session ID for the conversation]:uuid:' \
        '(-v --version)'{-v,--version}'[Output the version number]' \
        '(-h --help)'{-h,--help}'[Display help for command]' \
        '1: :->command' \
        '*: :->args' && return 0

    case $state in
        command)
            _describe -t commands 'claude commands' commands
            ;;
        args)
            case $words[1] in
                config)
                    _claude_config
                    ;;
                mcp)
                    _claude_mcp
                    ;;
                install)
                    _claude_install
                    ;;
                *)
                    _message 'prompt text'
                    ;;
            esac
            ;;
    esac
}

_claude_config() {
    local -a config_commands
    config_commands=(
COMPLETION_EOF

    # Add config commands
    echo "$config_commands" >> "$COMPLETION_FILE"

cat >> "$COMPLETION_FILE" << 'COMPLETION_EOF'
    )

    _arguments -C \
        '(-h --help)'{-h,--help}'[Display help for command]' \
        '1: :->subcommand' \
        '*: :->args' && return 0

    case $state in
        subcommand)
            _describe -t config-commands 'config commands' config_commands
            ;;
        args)
            case $words[2] in
                get)
                    _arguments \
                        '(-g --global)'{-g,--global}'[Use global config]' \
                        '1:key:_claude_config_keys'
                    ;;
                set)
                    _arguments \
                        '(-g --global)'{-g,--global}'[Use global config]' \
                        '1:key:_claude_config_keys' \
                        '2:value:'
                    ;;
                remove|rm)
                    _arguments \
                        '(-g --global)'{-g,--global}'[Use global config]' \
                        '1:key:_claude_config_keys' \
                        '*:values:'
                    ;;
                list|ls)
                    _arguments \
                        '(-g --global)'{-g,--global}'[Use global config]'
                    ;;
                add)
                    _arguments \
                        '(-g --global)'{-g,--global}'[Use global config]' \
                        '1:key:_claude_config_keys' \
                        '*:values:'
                    ;;
            esac
            ;;
    esac
}

_claude_mcp() {
    local -a mcp_commands
    mcp_commands=(
COMPLETION_EOF

    # Add MCP commands
    echo "$mcp_commands" >> "$COMPLETION_FILE"

cat >> "$COMPLETION_FILE" << 'COMPLETION_EOF'
    )

    _arguments -C \
        '(-h --help)'{-h,--help}'[Display help for command]' \
        '1: :->subcommand' \
        '*: :->args' && return 0

    case $state in
        subcommand)
            _describe -t mcp-commands 'mcp commands' mcp_commands
            ;;
        args)
            case $words[2] in
                serve)
                    _arguments \
                        '(-d --debug)'{-d,--debug}'[Enable debug mode]' \
                        '--verbose[Override verbose mode setting from config]'
                    ;;
                add)
                    _arguments \
                        '(-s --scope)'{-s,--scope}'[Configuration scope]:scope:(local user project)' \
                        '(-t --transport)'{-t,--transport}'[Transport type]:transport:(stdio sse http)' \
                        '(-e --env)'{-e,--env}'[Set environment variables]:env:' \
                        '(-H --header)'{-H,--header}'[Set WebSocket headers]:header:' \
                        '1:name:' \
                        '2:commandOrUrl:' \
                        '*:args:'
                    ;;
                remove)
                    _arguments \
                        '(-s --scope)'{-s,--scope}'[Configuration scope]:scope:(local user project)' \
                        '1:name:_claude_mcp_servers'
                    ;;
                get)
                    _arguments \
                        '1:name:_claude_mcp_servers'
                    ;;
                add-json)
                    _arguments \
                        '(-s --scope)'{-s,--scope}'[Configuration scope]:scope:(local user project)' \
                        '1:name:' \
                        '2:json:'
                    ;;
                add-from-claude-desktop)
                    _arguments \
                        '(-s --scope)'{-s,--scope}'[Configuration scope]:scope:(local user project)'
                    ;;
            esac
            ;;
    esac
}

_claude_install() {
    local -a install_targets
    install_targets=(
        'stable:Install stable version'
        'latest:Install latest version'
    )

    _arguments \
        '--force[Force installation even if already installed]' \
        '(-h --help)'{-h,--help}'[Display help for command]' \
        '1: :->target' && return 0

    case $state in
        target)
            _describe -t install-targets 'install targets' install_targets
            _message 'or specific version'
            ;;
    esac
}

# Helper function to complete model names
_claude_models() {
    local -a models
    models=(
        'sonnet:Latest Sonnet model'
        'opus:Latest Opus model'
        'haiku:Latest Haiku model'
        'claude-sonnet-4-20250514:Claude Sonnet 4'
        'claude-3-5-sonnet-20241022:Claude 3.5 Sonnet'
        'claude-3-5-haiku-20241022:Claude 3.5 Haiku'
        'claude-3-opus-20240229:Claude 3 Opus'
    )
    _describe -t models 'claude models' models
}

# Helper function to complete config keys
_claude_config_keys() {
    local -a config_keys
    config_keys=(
        'theme:UI theme setting'
        'allowedTools:Allowed tool names'
        'disallowedTools:Disallowed tool names'
        'hasTrustDialogAccepted:Trust dialog acceptance status'
        'hasCompletedProjectOnboarding:Project onboarding status'
        'permissionMode:Default permission mode'
        'model:Default model'
        'fallbackModel:Fallback model'
    )
    _describe -t config-keys 'config keys' config_keys
}

# Helper function to complete MCP server names
_claude_mcp_servers() {
    local -a servers
    # Try to get actual server names, fallback to common ones
    if command -v claude >/dev/null 2>&1; then
        servers=(${(f)"$(claude mcp list 2>/dev/null | grep -E '^[a-zA-Z0-9_-]+:' | cut -d: -f1)"})
    fi
    
    # Fallback to common server names if the command fails
    if [[ ${#servers} -eq 0 ]]; then
        servers=(
            'playwright:Playwright MCP server'
            'context7:Context7 MCP server'
            'github:GitHub MCP server'
            'zen-mcp-server:Zen MCP server'
            'vectorcode:VectorCode MCP server'
            'graphiti-memory:Graphiti Memory MCP server'
            'sequential-thinking:Sequential Thinking MCP server'
            'sentry:Sentry MCP server'
        )
    fi
    _describe -t mcp-servers 'MCP servers' servers
}

_claude "$@"
COMPLETION_EOF

    # Validate the generated completion file
    if ! zsh -n "$COMPLETION_FILE" 2>/dev/null; then
        error "Generated completion file has syntax errors"
    fi
    
    success "Updated Claude CLI completion: $COMPLETION_FILE"
}

main() {
    log "Starting Claude CLI completion generation (simple version)"
    check_claude_cli
    generate_completion
    
    # Add to git if not tracked
    if ! git -C "$DOTFILES_DIR" ls-files --error-unmatch "$COMPLETION_FILE" >/dev/null 2>&1; then
        log "Adding completion file to git..."
        git -C "$DOTFILES_DIR" add "$COMPLETION_FILE"
        success "Added completion file to git tracking"
    fi
    
    success "Claude CLI completion generation complete!"
    echo
    echo "To use the updated completion:"
    echo "  1. Reload your shell: exec zsh"
    echo "  2. Or source the completion: source $COMPLETION_FILE"
    echo "  3. Test with: claude <TAB>"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi